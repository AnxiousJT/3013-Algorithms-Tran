/*
@FileName: BSTree.cpp
@Author: Jackson Tran
@Description: This cpp file will include the BSTree header file and define the 
methods to be used inside our binary search tree class. The assignment given
was to fix the delete method to work in cases where a node had only one child.
@Course: 3013 Agorithms
@Semester: Spring 2018
@Date: February 2018
*/


#include "BSTree.h"
#include <iostream>
#include <string>
#include <fstream>

using namespace std;

//************************************************************************
// The reasoning for having almost two versions of every method, public and
// private, is to make sure that anyone using the methods wouldn't change 
// any data being utilized in creating the BST.
//************************************************************************


//private methods start here
//************************************************************************
// Private version of count, called by public version. Will keep track of the
// number of nodes in the BST
//************************************************************************
int	BSTree::count(node *root)
{
	if (!root)
	{
		return 0;
	}
	else
	{
		return 1 + count(root->left) + count(root->right);
	}
}
//************************************************************************
// Private insert method, called by the public one. Will insert a node into 
// the BST
//************************************************************************
void BSTree::insert(node *&root, node *&temp)
{
	if (!root)
	{
		root = temp;
	}
	else
	{
		if (temp->data < root->data)
		{
			insert(root->left, temp);
		}
		else
		{
			insert(root->right, temp);
		}
	}
}
//************************************************************************
// A more complex print method that create a sort of visualization of the BST
//************************************************************************
void BSTree::print_node(node *n, string label)
{
	if (label != "")
	{
		cout << "[" << label << "]";
	}
	cout << "[[" << n << "][" << n->data << "]]\n";
	if (n->left)
	{
		cout << "\t|-->[L][[" << n->left << "][" << n->left->data << "]]\n";
	}
	else
	{
		cout << "\t\\-->[L][null]\n";
	}
	if (n->right)
	{
		cout << "\t\\-->[R][[" << n->right << "][" << n->right->data << "]]\n";
	}
	else
	{
		cout << "\t\\-->[R][null]\n";
	}
}

/**
* type = ['predecessor','successor']
*/
node* BSTree::minValueNode(node *root)
{
	node *current = root;

	if (root->right)
	{
		current = root->right;
		while (current->left != NULL)
		{
			current = current->left;
		}
	}
	else if (root->left)
	{
		current = root->left;
		while (current->right != NULL)
		{
			current = current->right;
		}
	}

	return current;
}
//************************************************************************
// Private version od deleteNOde, called by the public version. Will delete
// a node equal to the data of the value passed in.
//************************************************************************
node* BSTree::deleteNode(node *&root, int key)
{
	if (!root)
	{
		return NULL;
	}
	if (key < root->data)
	{
		cout << "going left" << endl;
		root->left = deleteNode(root->left, key);
	}
	else if (key > root->data)
	{
		cout << "going right" << endl;
		root->right = deleteNode(root->right, key);
	}
	else
	{
		if (root->left == NULL)
		{
			node *temp = root->right;
			delete root;
			return temp;
		}
		else if (root->right == NULL)
		{
			node *temp = root->left;
			delete root;
			return temp;
		}

		// node with two children: Get the inorder successor (smallest
		// in the right subtree)
		node *temp = minValueNode(root);

		print_node(temp, "minvaluenode");

		// Copy the inorder successor's content to this node
		root->data = temp->data;

		// Delete the inorder successor
		root->right = deleteNode(root->right, temp->data);
	}
	return root;
}
//************************************************************************
// Private version of height, called by public version. Keeps track of the
// heights of the left and right subtrees
//************************************************************************
int BSTree::height(node *root)
{
	if (!root)
	{
		return 0;
	}
	else
	{
		int left = height(root->left);
		int right = height(root->right);
		if (left > right)
		{
			return left + 1;
		}
		else
		{
			return right + 1;
		}
	}
}

/* Print nodes at a given level */
void BSTree::printGivenLevel(node *root, int level)
{
	if (root == NULL)
		return;
	if (level == 1)
	{
		print_node(root);
	}
	else if (level > 1)
	{
		printGivenLevel(root->left, level - 1);
		printGivenLevel(root->right, level - 1);
	}
}
//************************************************************************
// Method to help create GraphViz code so the expression tree can
// be visualized. This method prints out all the unique node id's
// by traversing the tree.
// Recivies a node pointer to root and performs a simple recursive
// tree traversal.
//************************************************************************
void BSTree::GraphVizGetIds(node *nodePtr, ofstream &VizOut)
{
	static int NullCount = 0;
	if (nodePtr)
	{
		GraphVizGetIds(nodePtr->left, VizOut);
		VizOut << "node" << nodePtr->data
			<< "[label=\"" << nodePtr->data << "\\n"
			//<<"Add:"<<nodePtr<<"\\n"
			//<<"Par:"<<nodePtr->parent<<"\\n"
			//<<"Rt:"<<nodePtr->right<<"\\n"
			//<<"Lt:"<<nodePtr->left<<"\\n"
			<< "\"]" << endl;
		if (!nodePtr->left)
		{
			NullCount++;
			VizOut << "nnode" << NullCount << "[label=\"X\",shape=point,width=.15]" << endl;
		}
		GraphVizGetIds(nodePtr->right, VizOut);
		if (!nodePtr->right)
		{
			NullCount++;
			VizOut << "nnode" << NullCount << "[label=\"X\",shape=point,width=.15]" << endl;
		}
	}
}

//************************************************************************
// This method is partnered with the above method, but on this pass it
// writes out the actual data from each node.
// Don't worry about what this method and the above method do, just
// use the output as your told:)
//************************************************************************
void BSTree::GraphVizMakeConnections(node *nodePtr, ofstream &VizOut)
{
	static int NullCount = 0;
	if (nodePtr)
	{
		GraphVizMakeConnections(nodePtr->left, VizOut);
		if (nodePtr->left)
			VizOut << "node" << nodePtr->data << "->"
			<< "node" << nodePtr->left->data << endl;
		else
		{
			NullCount++;
			VizOut << "node" << nodePtr->data << "->"
				<< "nnode" << NullCount << endl;
		}

		if (nodePtr->right)
			VizOut << "node" << nodePtr->data << "->"
			<< "node" << nodePtr->right->data << endl;
		else
		{
			NullCount++;
			VizOut << "node" << nodePtr->data << "->"
				<< "nnode" << NullCount << endl;
		}

		GraphVizMakeConnections(nodePtr->right, VizOut);
	}
}
//private methods end here
//public methods start here
//************************************************************************
// Constructor for the class
//************************************************************************
BSTree::BSTree()
{
	root = NULL;
}
//************************************************************************
// Destructor for the class
//************************************************************************
BSTree::~BSTree()
{
}
//************************************************************************
// Punblic version of count, calls private method count which will return
// the number of nodes in the tree.
//************************************************************************
int BSTree::count()
{
	return count(root);
}
//************************************************************************
// Public method insert will create a new node with data passed in from int x
// and it will then call the private method insert to add the node to the BST
//************************************************************************
void BSTree::insert(int x)
{
	node *temp = new node(x);
	insert(root, temp);
}
//************************************************************************
// Public method deleteNode, calls private deleteNode method to delete a node
// in the BST with data equal to the key passed in. The fix for this method, in
// correlation with the private version, is that it wasn't setting a new root
// in the BST. So by assigning root the return from the private deleteNode,
// the BST wouldn't be destroyed completely.
//************************************************************************
void BSTree::deleteNode(int key)
{
	root = deleteNode(root, key);
}
//************************************************************************
// Public method minValue, calls private method minValueNode to print out the
// node with the minimum value
//************************************************************************
void BSTree::minValue()
{
	print_node(minValueNode(root), "minVal");
}
//************************************************************************
// Public version of height, calls private version of height.
//************************************************************************
int BSTree::height(int key = -1)
{
	if (key > 0)
	{
		//find node
	}
	else
	{
		return height(root);
	}
	return 0;
}

//************************************************************************
// Returns the data in root, if available. Returns zero if not.
//************************************************************************
int BSTree::top()
{
	if (root)
		return root->data;
	else
		return 0;
}

/* Function to line by line print level order traversal a tree*/
void BSTree::printLevelOrder()
{
	cout << "Begin Level Order===================\n";
	int h = height(root);
	int i;
	for (i = 1; i <= h; i++)
	{
		printGivenLevel(root, i);
		cout << "\n";
	}
	cout << "End Level Order===================\n";
}

//************************************************************************
// Recieves a filename to place the GraphViz data into.
// It then calls the above two graphviz methods to create a data file
// that can be used to visualize your expression tree.
//************************************************************************
void BSTree::GraphVizOut(string filename)
{
	ofstream VizOut;
	VizOut.open(filename);
	VizOut << "Digraph G {\n";
	GraphVizGetIds(root, VizOut);
	GraphVizMakeConnections(root, VizOut);
	VizOut << "}\n";
	VizOut.close();
}
